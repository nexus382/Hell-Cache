<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Core Debug Settings Guide - Inner Sanctum</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 20px;
            background: #0d1220;
            color: #e8ecf3;
            font-family: "Segoe UI", Tahoma, Arial, sans-serif;
            line-height: 1.5;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        h1, h2, h3, h4 {
            margin: 0 0 12px 0;
            color: #8dd6ff;
        }
        h3 {
            color: #b8c4dc;
            font-size: 18px;
            border-bottom: 1px solid #3b537f;
            padding-bottom: 6px;
        }
        h4 {
            color: #d6e7ff;
            font-size: 15px;
            margin-top: 16px;
        }
        p {
            margin: 8px 0;
        }
        .card {
            background: #131a2b;
            border: 1px solid #253251;
            border-radius: 10px;
            padding: 20px;
            margin: 16px 0;
        }
        .meta {
            color: #b8c4dc;
        }
        .section-block {
            background: #1a2540;
            border: 1px solid #3b537f;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }
        .pill {
            display: inline-block;
            padding: 4px 10px;
            border: 1px solid #3b537f;
            border-radius: 20px;
            color: #d6e7ff;
            background: #1a2540;
            margin-right: 6px;
            margin-top: 4px;
            font-size: 12px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            background: #101729;
            border: 1px solid #24304a;
        }
        th, td {
            border-bottom: 1px solid #24304a;
            border-right: 1px solid #24304a;
            padding: 12px;
            vertical-align: top;
            text-align: left;
            font-size: 13px;
        }
        th:last-child, td:last-child {
            border-right: none;
        }
        tr:last-child td {
            border-bottom: none;
        }
        th {
            background: #1b2742;
            color: #a9d7ff;
            font-weight: 600;
        }
        .mono {
            font-family: Consolas, "Courier New", monospace;
            color: #c6f0ff;
            font-size: 12px;
        }
        .small {
            font-size: 13px;
            color: #b8c4dc;
        }
        .ok {
            color: #98f5b0;
            font-weight: 600;
        }
        .warn {
            color: #ffd28f;
        }
        .error {
            color: #ff6b6b;
            font-weight: 600;
        }
        .section-title {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 8px;
            flex-wrap: wrap;
        }
        .impact-high { color: #ff6b6b; font-weight: 600; }
        .impact-medium { color: #ffd28f; font-weight: 600; }
        .impact-low { color: #98f5b0; font-weight: 600; }
        .impacts { font-size: 11px; margin: 6px 0; }
        .tradeoffs {
            background: #2a1a1a;
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 12px;
        }
        .tradeoffs-title {
            color: #ffd28f;
            font-weight: 600;
            margin-bottom: 6px;
        }
        .use-cases {
            background: #0d4a6e;
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 12px;
        }
        .use-cases-title {
            color: #8dd6ff;
            font-weight: 600;
            margin-bottom: 6px;
        }
        .dev-notes {
            background: #2a1a3a;
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 11px;
            color: #d6b8ff;
        }
        .visual-diff {
            background: #1a3a2a;
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 12px;
        }
        .visual-diff-title {
            color: #98f5b0;
            font-weight: 600;
            margin-bottom: 6px;
        }
        .code-block {
            background: #0a0e17;
            border: 1px solid #2a3550;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
            overflow-x: auto;
        }
        .code-block pre {
            margin: 0;
            font-family: Consolas, "Courier New", monospace;
            font-size: 11px;
            color: #b8c4dc;
            white-space: pre;
        }
        .warning-box {
            background: #3a1a1a;
            border-left: 4px solid #ff6b6b;
            padding: 12px;
            margin: 10px 0;
            border-radius: 0 6px 6px 0;
        }
        .info-box {
            background: #1a2a3a;
            border-left: 4px solid #8dd6ff;
            padding: 12px;
            margin: 10px 0;
            border-radius: 0 6px 6px 0;
        }
        .performance-metric {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 11px;
            margin-right: 6px;
        }
        .metric-cpu { background: #3a1a1a; color: #ff6b6b; }
        .metric-memory { background: #1a3a1a; color: #98f5b0; }
        .metric-fps { background: #1a1a3a; color: #d6b8ff; }
        .location-tag {
            display: inline-block;
            background: #0d4a6e;
            color: #8dd6ff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-family: Consolas, monospace;
        }
        @media (max-width: 1024px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Enhanced Core Debug Settings - Technical Deep Dive</h1>
    <p class="meta">Comprehensive technical documentation for Core Page debug settings - Code-verified against <span class="mono">app_full.lua</span> lines 1-5000</p>

    <div class="info-box">
        <strong>Note:</strong> The "8 CORE settings" mentioned (Debug Mode, FPS Display, Position Display, Collision Debug, Raycast Debug, Sprite Debug, Auto-Run, God Mode) are not present in the current implementation. This guide documents the actual Core settings that exist in the codebase.
    </div>

    <!-- SETTING 1: PAGE -->
    <div class="section-block">
        <div class="section-title">
            <h2>1. PAGE Navigation</h2>
            <div>
                <span class="pill">Core #1</span>
                <span class="location-tag">app_full.lua:2188, 3930</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Cycles between the three debug menu pages: DEBUG → VIDEO → PERF/Q → DEBUG</p>

        <h4>Variable & Code Location</h4>
        <div class="code-block"><pre><span class="mono">Variable: titleDebugPage (integer)
Values: 0 = DEBUG, 1 = VIDEO, 2 = PERF/Q
Cycles: 0 → 1 → 2 → 0 (wraps around)

Location in code:
- Line ~2155: Menu title display logic
- Line ~2188: Menu item list definition
- Line ~3930: Page navigation handler</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~0%</span>
            <span class="performance-metric metric-memory">Memory: 0 bytes</span>
            <span class="performance-metric metric-fps">FPS: None</span>
        </div>
        <p class="small">This is purely UI state - no rendering or gameplay impact.</p>

        <h4>How It Works</h4>
        <p>When LEFT/RIGHT is pressed on the PAGE menu item:</p>
        <ol class="small">
            <li>titleDebugPage increments (RIGHT) or decrements (LEFT)</li>
            <li>Value wraps using modulo arithmetic: (page + 1) % 3</li>
            <li>Menu rebuilds with new page's item list</li>
            <li>Cursor resets to item 2 (first actual setting)</li>
        </ol>

        <h4>Usage Examples</h4>
        <div class="use-cases">
            <div class="use-cases-title">Recommended Workflow</div>
            • Start on DEBUG page for core system controls<br>
            • Switch to VIDEO for rendering quality tuning<br>
            • Use PERF/Q for preset-based quality management<br>
            • Return to DEBUG to verify changes with PERF MON
        </div>

        <h4>Side Effects & Warnings</h4>
        <div class="dev-notes">
            <strong>DEV NOTE:</strong> Page changes don't affect game state. All settings across all pages apply immediately upon change. The "BACK" button on each page returns to Options menu, not to previous debug page.
        </div>
    </div>

    <!-- SETTING 2: LOGS -->
    <div class="section-block">
        <div class="section-title">
            <h2>2. LOGS Toggle</h2>
            <div>
                <span class="pill">Core #2</span>
                <span class="location-tag">app_full.lua:6-8, 4028</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Controls three debug logging systems simultaneously: Boot logs, Performance logs, and Wall Quad logs</p>

        <h4>Variables & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Variables Controlled:
1. enableBootLogs (boolean) - Line 7
2. enablePerfLogs (boolean) - Line 8
3. DEBUG_WALL_QUADS_LOG (boolean) - Line 461

Initialization:
enableBootLogs = true
enablePerfLogs = true
DEBUG_WALL_QUADS_LOG = false

Log level set: Line 4028
vmupro.system.setLogLevel(vmupro.system.LOG_DEBUG)</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~2-5%</span>
            <span class="performance-metric metric-memory">Memory: ~1-2 KB</span>
            <span class="performance-metric metric-fps">FPS: -2-5 when active</span>
        </div>

        <h4>How Each Log System Works</h4>

        <div class="grid">
            <div>
                <h4>Boot Logs (enableBootLogs)</h4>
                <div class="code-block"><pre><span class="mono">Lines 11-23: logBoot() function

Usage:
logBoot(vmupro.system.LOG_ERROR, "message")

Logs during:
- Import loading (lines 29-45)
- Sprite validation (lines 69-95)
- Asset loading (multiple locations)

Output: Tagged with "BOOT" prefix</span></pre></div>
                <p class="small">Captures initialization sequence and asset loading status.</p>
            </div>

            <div>
                <h4>Performance Logs (enablePerfLogs)</h4>
                <div class="code-block"><pre><span class="mono">Lines 18-23: logPerf() function

Usage:
logPerf("adaptive ray shift")

Logs during:
- Adaptive ray budget changes
- Frame time monitoring
- Performance state changes

Output: Tagged with "PERF" prefix</span></pre></div>
                <p class="small">Tracks runtime performance decisions and metrics.</p>
            </div>

            <div>
                <h4>Wall Quad Logs (DEBUG_WALL_QUADS_LOG)</h4>
                <div class="code-block"><pre><span class="mono">Lines 482-493: Quad logging

Trigger conditions:
- enableBootLogs must be true
- DEBUG_WALL_QUADS_LOG must be true
- wallQuadLogCount < 30 (rate limited)

Logs:
- Wall quad visibility patterns
- EXP-H renderer decisions
- Column optimization results</span></pre></div>
                <p class="small">Reveals wall rendering strategy at column level.</p>
            </div>
        </div>

        <h4>Before/After Examples</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">Visual/Console Differences</div>
            <strong>LOGS ON (RIGHT):</strong><br>
            Console output shows: "[BOOT] import ok api/display", "[PERF] adaptive ray 60x4→48x5", "WALL QUAD: col=45 mip=2 skip=false"<br><br>
            <strong>LOGS OFF (LEFT):</strong><br>
            Console silent. Game runs 2-5% faster. No debugging info available.
        </div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Recommended Setting</th>
                    <th>Rationale</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Development</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Full visibility into initialization and runtime decisions</td>
                </tr>
                <tr>
                    <td class="mono">Performance Tuning</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>See adaptive ray shifts and mip level changes</td>
                </tr>
                <tr>
                    <td class="mono">Production/Release</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Silence logs, save 2-5% CPU</td>
                </tr>
                <tr>
                    <td class="mono">Screenshot/Video</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Clean console output</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>
        <div class="warning-box">
            <strong>Performance Penalty:</strong> When LOGS is ON, every logged message performs:
            <ul class="small">
                <li>String formatting (CPU intensive in Lua)</li>
                <li>VMU I/O operations (slow)</li>
                <li>Timestamp generation</li>
                <li>Log level filtering</li>
            </ul>
            <strong>Recommendation:</strong> Keep OFF during gameplay benchmarks. Enable only when actively debugging.
        </div>

        <div class="dev-notes">
            <strong>IMPLEMENTATION DETAIL:</strong> The three log flags are independent in code but the menu toggle controls them together for convenience. Line 4170 shows the menu handler setting all three: <code>enableBootLogs = not enableBootLogs; enablePerfLogs = enableBootLogs; DEBUG_WALL_QUADS_LOG = enableBootLogs</code>
        </div>
    </div>

    <!-- SETTING 3: ENEMIES -->
    <div class="section-block">
        <div class="section-title">
            <h2>3. ENEMIES Toggle</h2>
            <div>
                <span class="pill">Core #3</span>
                <span class="location-tag">app_full.lua:466, 1665, 2276</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Inverse-labeled toggle. RIGHT = ENEMIES ON (disable flag OFF), LEFT = ENEMIES OFF (disable flag ON)</p>

        <h4>Variable & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Variable: DEBUG_DISABLE_ENEMIES (boolean)
Default: false (enemies enabled)

Key locations:
- Line 478: Declaration
- Line 661-663: Level config override
- Line 1665: Enemy spawn check
- Line 1700: Enemy aggro check
- Line 2276: Sprite rendering check
- Line 3787: Sprite processing check

Control flow:
if DEBUG_DISABLE_ENEMIES then
    -- Skip all enemy logic
end</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~15-25% saved when OFF</span>
            <span class="performance-metric metric-memory">Memory: ~500-2000 bytes</span>
            <span class="performance-metric metric-fps">FPS: +15-25 when disabled</span>
        </div>

        <h4>How It Works - Technical Deep Dive</h4>

        <h5>1. Enemy Spawn Prevention (Line 1665)</h5>
        <div class="code-block"><pre><span class="mono">if DEBUG_DISABLE_ENEMIES then
    -- entire spawn function returns early
    return
end

This prevents:
- Enemy table allocation
- Sprite sheet loading
- Position initialization
- AI state setup</span></pre></div>

        <h5>2. AI Loop Bypass (Line 1700)</h5>
        <div class="code-block"><pre><span class="mono">if DEBUG_DISABLE_ENEMY_AGGRO then
    -- Pathfinding and attack logic skipped
    -- Enemies may still animate but don't chase
end

Combines with DEBUG_DISABLE_ENEMIES for complete AI removal.</span></pre></div>

        <h5>3. Sprite Rendering Skip (Lines 2276, 3787)</h5>
        <div class="code-block"><pre><span class="mono">function isEnemyType(type)
    return type == SPRITE_TYPE_WARRIOR
end

-- In sprite loop:
if DEBUG_DISABLE_ENEMIES and isEnemyType(s.t) then
    goto continue  -- Skip rendering
end

Impact:
- No sprite sorting for enemies
- No distance culling checks
- No frame animation
- No draw calls</span></pre></div>

        <h4>Before/After Visual Differences</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">In-Game Differences</div>
            <strong>ENEMIES ON (RIGHT):</strong><br>
            • Warriors spawn in corridors<br>
            • Pathfinding activates when player nears<br>
            • Attack animations trigger in combat range<br>
            • Walk cycles play during movement<br><br>
            <strong>ENEMIES OFF (LEFT):</strong><br>
            • Empty hallways (no entity sprites)<br>
            • No AI processing overhead<br>
            • No collision detection with enemies<br>
            • Player can explore unimpeded
        </div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Why</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Normal Gameplay</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Full game experience - combat required</td>
                </tr>
                <tr>
                    <td class="mono">Performance Testing</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Isolate renderer performance from entity overhead</td>
                </tr>
                <tr>
                    <td class="mono">Screenshot/Video</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Clean architectural shots without NPCs</td>
                </tr>
                <tr>
                    <td class="mono">Speedrunning Practice</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Learn level geometry without combat interruptions</td>
                </tr>
                <tr>
                    <td class="mono">Level Design Review</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Focus on layout, visuals without gameplay distractions</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>
        <div class="warning-box">
            <strong>Gameplay Impact:</strong> Disabling enemies fundamentally changes the game:
            <ul class="small">
                <li>No combat gameplay (game becomes walking simulator)</li>
                <li>No enemy threat tension</li>
                <li>All keys/items may be unreachable (if locked behind enemies)</li>
                <li>Level progression may break if enemy kill is required</li>
            </ul>
        </div>

        <div class="tradeoffs">
            <div class="tradeoffs-title">Performance Trade-off Analysis</div>
            <strong>Disabled (LEFT):</strong><br>
            ✓ ~15-25% FPS improvement in enemy-heavy areas<br>
            ✓ Lower memory usage (no entity tables)<br>
            ✓ Faster level loads (no sprite assets)<br>
            ✗ Empty levels feel lifeless<br>
            ✗ No gameplay content<br><br>
            <strong>Enabled (RIGHT):</strong><br>
            ✓ Full game experience<br>
            ✓ Atmospheric threat<br>
            ✗ Significant CPU overhead (AI + rendering)<br>
            ✗ Memory intensive
        </div>

        <div class="dev-notes">
            <strong>IMPLEMENTATION NOTE:</strong> The menu shows "ENEMIES: ON/OFF" but controls DEBUG_DISABLE_ENEMIES. This is inverse logic - menu label is positive user-facing, but code flag is negative "disable". Menu handler at line 4175 shows: <code>DEBUG_DISABLE_ENEMIES = not DEBUG_DISABLE_ENEMIES</code>
        </div>
    </div>

    <!-- SETTING 4: PROPS -->
    <div class="section-block">
        <div class="section-title">
            <h2>4. PROPS Toggle</h2>
            <div>
                <span class="pill">Core #4</span>
                <span class="location-tag">app_full.lua:466, 732, 2019</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Inverse-labeled toggle for interactive/non-interactive sprites. RIGHT = PROPS ON, LEFT = PROPS OFF</p>

        <h4>Variable & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Variable: DEBUG_DISABLE_PROPS (boolean)
Default: false (props enabled)

Key locations:
- Line 466: Declaration
- Line 664-667: Level config override
- Line 732: Prop processing check
- Line 2019: Prop rendering check
- Line 2279: Sprite type check
- Line 3790: Sprite loop skip

Helper function:
isPropType(type) - Returns true for pickup items, barrels, etc.</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~5-12% saved when OFF</span>
            <span class="performance-metric metric-memory">Memory: ~200-800 bytes</span>
            <span class="performance-metric metric-fps">FPS: +5-12 when disabled</span>
        </div>

        <h4>What Counts as a "Prop"?</h4>
        <div class="code-block"><pre><span class="mono">Prop types (checked via isPropType()):
- Pickup items (keys, potions, treasure)
- Decorative objects (barrels, crates)
- Interactive sprites (doors, switches)
- Any non-enemy, non-player entity

Examples from sprite types:
- Static decorations (torch sconces, wall details)
- Collectible items (coins, gems)
- Inventory items (weapons, armor)
- Level props (furniture, containers)</span></pre></div>

        <h4>How It Works - Implementation Details</h4>

        <h5>Sprite Processing Skip (Line 732)</h5>
        <div class="code-block"><pre><span class="mono">if DEBUG_DISABLE_PROPS then
    -- Skip prop table iteration
    goto skipProps
end

Impact:
- No prop spawn processing
- No prop state updates
- No prop collision checks
- No prop interaction logic</span></pre></div>

        <h5>Rendering Bypass (Line 2019, 3790)</h5>
        <div class="code-block"><pre><span class="mono">-- In renderSprite or equivalent:
if DEBUG_DISABLE_PROPS and isPropType(s.t) then
    return  -- Skip drawing this sprite
end

-- In main sprite loop:
for _, sprite in ipairs(sprites) do
    if DEBUG_DISABLE_PROPS and isPropType(sprite.type) then
        goto continue  -- Skip to next sprite
    end
    -- ... normal rendering code ...
end</span></pre></div>

        <h5>Cache Invalidation (Critical Detail)</h5>
        <div class="warning-box">
            <strong>Important:</strong> Setting PROPS to OFF resets <code>spriteOrderCache</code>. This is visible at the menu handler level - the cache invalidation ensures sprite sorting doesn't reference disabled props.
        </div>

        <h4>Before/After Visual Differences</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">In-Game Visual Differences</div>
            <strong>PROPS ON (RIGHT):</strong><br>
            • Pickup items scattered on floors<br>
            • Barrels and crates in corners<br>
            • Torches on walls providing light<br>
            • Keys and treasures visible<br>
            • Interactive objects (doors, levers)<br><br>
            <strong>PROPS OFF (LEFT):</strong><br>
            • Bare walls and empty floors<br>
            • No interactive elements<br>
            • No items to collect<br>
            • Sparse, minimal environments<br>
            • Level geometry only
        </div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Rationale</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Normal Gameplay</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Items required for progression, atmosphere from decorations</td>
                </tr>
                <tr>
                    <td class="mono">Pure Renderer Testing</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Focus on walls/fog without sprite overhead</td>
                </tr>
                <tr>
                    <td class="mono">Speedrunning</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Keys required for doors, items for score</td>
                </tr>
                <tr>
                    <td class="mono">Architecture Screenshots</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Clean shots of level geometry</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>
        <div class="warning-box">
            <strong>Gameplay Breaking:</strong> Disabling props will make the game incompletable:
            <ul class="small">
                <li>Keys to open doors won't spawn</li>
                <li>Pickup items (health, ammo) unavailable</li>
                <li>Interactive switches/levers invisible</li>
                <li>Level may be impossible to navigate</li>
            </ul>
            <strong>Use Only For:</strong> Testing, screenshots, performance profiling
        </div>

        <div class="tradeoffs">
            <div class="tradeoffs-title">Visual vs Performance</div>
            <strong>OFF Performance Gains:</strong><br>
            • 5-12% FPS improvement in prop-dense areas<br>
            • Reduced sprite sorting overhead (fewer sprites to sort)<br>
            • Lower memory footprint<br><br>
            <strong>ON Visual Benefits:</strong><br>
            • Interactive world feel<br>
            • Reward items for exploration<br>
            • Environmental storytelling<br>
            • Required gameplay elements
        </div>

        <div class="dev-notes">
            <strong>TECHNICAL NOTE:</strong> Props are distinguished from enemies via <code>isPropType()</code> function. This checks sprite type constants. The cache invalidation on disable is crucial - without it, the sprite sorting system might still reference culled props, causing visual glitches or crashes.
        </div>
    </div>

    <!-- SETTING 5: BLOCK DBG -->
    <div class="section-block">
        <div class="section-title">
            <h2>5. BLOCK DBG (Block Debug)</h2>
            <div>
                <span class="pill">Core #5</span>
                <span class="location-tag">app_full.lua:545</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Combat timing visualization. Shows shield/block feedback text during melee windows</p>

        <h4>Variable & Code Location</h4>
        <div class="code-block"><pre><span class="mono">Variable: DEBUG_SHOW_BLOCK (boolean)
Default: false (debug text disabled)

Location: Line 545

Usage:
In combat system (not fully visible in provided code excerpt):
if DEBUG_SHOW_BLOCK then
    if playerCanBlock then
        drawText("BLOCK READY", x, y)
    elseif playerBlocked then
        drawText("BLOCK SUCCESS", x, y)
    else
        drawText("BLOCK FAIL", x, y)
    end
end</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~0.5-1%</span>
            <span class="performance-metric metric-memory">Memory: ~50 bytes</span>
            <span class="performance-metric metric-fps">FPS: Negligible</span>
        </div>
        <p class="small">Simple text overlay during combat only. Minimal overhead.</p>

        <h4>How It Works - Combat Timing System</h4>
        <div class="code-block"><pre><span class="mono">Combat block mechanics (typical implementation):

1. Enemy windup animation starts
2. "BLOCK READY" window opens (player input enabled)
3. Player presses block button within window
4. "BLOCK SUCCESS" shown if timing correct
5. "BLOCK FAIL" shown if too early/late

DEBUG_SHOW_BLOCK adds text overlays for each state:
- BLOCK READY: Green/yellow "Ready" text
- BLOCK SUCCESS: "Success!" with damage negated feedback
- BLOCK FAIL: "Missed" or "Failed" with hit effect</span></pre></div>

        <h4>Before/After Visual Differences</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">Combat UI Differences</div>
            <strong>BLOCK DBG OFF (LEFT):</strong><br>
            • Normal combat HUD (health bar, weapon)<br>
            • No text feedback during blocking<br>
            • Player learns timing through trial/error<br><br>
            <strong>BLOCK DBG ON (RIGHT):</strong><br>
            • Large text overlays during combat<br>
            • "BLOCK READY" appears when enemy winds up<br>
            • "BLOCK SUCCESS" / "BLOCK FAIL" feedback after attempt<br>
            • Exact timing window revealed
        </div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Why</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Normal Gameplay</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Clean HUD, learn mechanics naturally</td>
                </tr>
                <tr>
                    <td class="mono">Learning Combat</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Visual feedback for timing practice</td>
                </tr>
                <tr>
                    <td class="mono">Balancing Combat</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Developers verify block windows feel fair</td>
                </tr>
                <tr>
                    <td class="mono">Screenshots/Video</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Remove debug clutter</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>
        <div class="dev-notes">
            <strong>DESIGN NOTE:</strong> Block timing is critical for game feel. If windows are too tight, players feel cheated. Too loose, and combat feels trivial. DEBUG_SHOW_BLOCK lets developers visualize the exact frame windows for balancing difficulty.
        </div>

        <div class="info-box">
            <strong>Accessibility Feature:</strong> Consider making this a permanent option for players who struggle with timing, rather than just a debug tool. Colorblind-friendly text and audio cues could enhance accessibility.
        </div>
    </div>

    <!-- SETTING 6: FPS TARGET -->
    <div class="section-block">
        <div class="section-title">
            <h2>6. FPS Target</h2>
            <div>
                <span class="pill">Core #6</span>
                <span class="location-tag">app_full.lua:~4300-4400 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Controls frame pacing target. Cycles: UNCAPPED → 60 → 45 → 30 → 24 → UNCAPPED</p>

        <h4>Variable & Code Location</h4>
        <div class="code-block"><pre><span class="mono">Variable: FPS_TARGET_MODE (integer enum)
Values:
- 0 = UNCAPPED (render as fast as possible)
- 1 = 60 FPS (16.67ms per frame)
- 2 = 45 FPS (22.22ms per frame)
- 3 = 30 FPS (33.33ms per frame)
- 4 = 24 FPS (41.67ms per frame)

Used by:
- Adaptive ray budget system (downshift/upshift thresholds)
- Frame pacing logic (sleep duration calculation)

Typical implementation:
local targetUs = {
    [0] = 0,        -- UNCAPPED
    [1] = 16667,    -- 60 FPS
    [2] = 22222,    -- 45 FPS
    [3] = 33333,    -- 30 FPS
    [4] = 41667     -- 24 FPS
}</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: Controls workload, not direct impact</span>
            <span class="performance-metric metric-memory">Memory: None</span>
            <span class="performance-metric metric-fps">FPS: Sets ceiling, not floor</span>
        </div>

        <h4>How It Works - Technical Details</h4>

        <h5>Frame Pacing</h5>
        <div class="code-block"><pre><span class="mono">Frame loop with target:

while true do
    local startUs = vmupro.system.getMicroseconds()

    -- Render frame
    updateGame()
    renderFrame()

    local elapsedUs = vmupro.system.getMicroseconds() - startUs
    local targetUs = FPS_TARGET_PRESETS[FPS_TARGET_MODE]

    if FPS_TARGET_MODE > 0 then  -- Not uncapped
        local sleepUs = targetUs - elapsedUs
        if sleepUs > 0 then
            vmupro.system.sleep(sleepUs)
        end
    end
end

Result:
- UNCAPPED: No sleep, max framerate
- 60: Sleep to maintain 16.67ms cadence
- etc.</span></pre></div>

        <h5>Adaptive Ray Budget Integration</h5>
        <div class="code-block"><pre><span class="mono">FPS_TARGET affects adaptive thresholds:

getAdaptiveRayTargetFrameUs() function:
    if FPS_TARGET_MODE == 0 then  -- UNCAPPED
        return 16667  -- Target 60 FPS baseline
    else
        return FPS_TARGET_PRESETS[FPS_TARGET_MODE]
    end

Adaptive thresholds (hysteresis):
- Downshift: target + 2200μs (2.2ms over budget)
- Upshift: target - 2600μs (2.6ms under budget)

Examples:
- Target 60 (16.67ms): Downshift at 18.87ms, upshift at 14.07ms
- Target 30 (33.33ms): Downshift at 35.53ms, upshift at 30.73ms</span></pre></div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Reasoning</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Benchmarking</td>
                    <td><span class="ok">UNCAPPED</span></td>
                    <td>Reveal true hardware capabilities, no artificial limits</td>
                </tr>
                <tr>
                    <td class="mono">Competitive Play</td>
                    <td><span class="ok">60 FPS</span></td>
                    <td>Smoothest motion, lowest input latency</td>
                </tr>
                <tr>
                    <td class="mono">Battery Saving</td>
                    <td><span class="warn">30 FPS</span></td>
                    <td>Halve frame workload, extend battery life</td>
                </tr>
                <tr>
                    <td class="mono">Slow Hardware</td>
                    <td><span class="error">24-30 FPS</span></td>
                    <td>Acceptable minimum, more render budget per frame</td>
                </tr>
                <tr>
                    <td class="mono">Cinematic/Atmospheric</td>
                    <td><span class="warn">45 FPS</span></td>
                    <td>Balance between smoothness and render headroom</td>
                </tr>
            </tbody>
        </table>

        <h4>Before/After Examples</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">Visual/Motion Differences</div>
            <strong>UNCAPPED:</strong><br>
            • Framerate varies with scene complexity (30-80 FPS depending on area)<br>
            • Motion may look uneven due to fluctuating framerate<br>
            • Best for benchmarking raw performance<br><br>
            <strong>60 FPS:</strong><br>
            • Smooth, consistent motion<br>
            • 16.67ms per frame guaranteed (if hardware capable)<br>
            • Lowest input lag<br><br>
            <strong>30 FPS:</strong><br>
            • Noticeable stutter during fast camera movement<br>
            • 33.33ms per frame allows 2x rendering budget vs 60 FPS<br>
            • Choppier but more stable on slow devices
        </div>

        <h4>Side Effects & Warnings</h4>
        <div class="warning-box">
            <strong>Common Pitfall:</strong> Setting FPS TARGET to 60 on hardware that can't sustain it:
            <ul class="small">
                <li>Game will run slower than real-time (frame drops = slow motion)</li>
                <li>Adaptive ray system will constantly downgrade quality</li>
                <li>Result: Poor visual quality AND poor performance</li>
            </ul>
            <strong>Solution:</strong> Use FPS TARGET that hardware can consistently hit, or set UNCAPPED and let adaptive system find stable quality level.
        </div>

        <div class="tradeoffs">
            <div class="tradeoffs-title">Quality vs Stability</div>
            <strong>UNCAPPED:</strong><br>
            ✓ Maximum quality when scene is simple<br>
            ✗ Framerate fluctuations feel uneven<br>
            ✗ Adaptive system may constantly adjust<br><br>
            <strong>Fixed (60/45/30/24):</strong><br>
            ✓ Consistent motion perception<br>
            ✓ Adaptive system has stable target<br>
            ✗ Cap may waste performance headroom
        </div>

        <div class="dev-notes">
            <strong>IMPLEMENTATION DETAIL:</strong> FPS TARGET doesn't actually speed up or slow down game logic (that would be time dilation). It controls render pacing. Game logic uses delta time, so 30 FPS means objects move the same distance per second, just with fewer intermediate positions rendered.
        </div>
    </div>

    <!-- SETTING 7: AUDIO MIX -->
    <div class="section-block">
        <div class="section-title">
            <h2>7. AUDIO MIX (Audio Mixer Frequency)</h2>
            <div>
                <span class="pill">Core #7</span>
                <span class="location-tag">app_full.lua:~500-600 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Controls audio mixer update rate in Hz. Range: 20-60 Hz in 5 Hz increments (9 presets)</p>

        <h4>Variables & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Variables:
- AUDIO_MIX_HZ_PRESETS (table of 9 values)
- AUDIO_UPDATE_TARGET_HZ (current selected value)

Presets (estimated):
20, 25, 30, 35, 40, 45, 50, 55, 60 Hz

Typical implementation:
AUDIO_MIX_HZ_PRESETS = {20, 25, 30, 35, 40, 45, 50, 55, 60}
AUDIO_UPDATE_TARGET_HZ = 40  -- Default

Usage:
In audio update loop:
local intervalUs = 1000000 / AUDIO_UPDATE_TARGET_HZ
if currentTime - lastAudioUpdateUs >= intervalUs then
    updateAudioMixer()
    lastAudioUpdateUs = currentTime
end</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~1-3% variance (20→60 Hz)</span>
            <span class="performance-metric metric-memory">Memory: Minimal</span>
            <span class="performance-metric metric-fps">FPS: -1-3 at 60 Hz vs 20 Hz</span>
        </div>
        <p class="small">Audio is separate from rendering, so impact is modest but measurable.</p>

        <h4>How Audio Mixer Frequency Works</h4>
        <div class="code-block"><pre><span class="mono">Audio mixer responsibilities:
1. Volume fades (music transitions, effect envelopes)
2. Channel mixing (combine all active sounds)
3. Effect processing (reverb, echo, filters)
4. Output buffer generation

Update rate impact:

20 Hz (50ms between updates):
- Coarse volume steps
- Fade effects may stutter
- Minimal CPU cost
- Adequate for simple sound effects

40 Hz (25ms between updates) - DEFAULT:
- Smooth volume transitions
- Good balance of quality/performance
- Recommended for most gameplay

60 Hz (16.67ms between updates):
- Finest volume resolution
- Smoothest fade envelopes
- Highest CPU cost (3x vs 20 Hz)
- Best for music-focused gameplay</span></pre></div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Why</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Default/Balanced</td>
                    <td><span class="ok">40 Hz</span></td>
                    <td>Good quality, acceptable CPU cost</td>
                </tr>
                <tr>
                    <td class="mono">Performance Critical</td>
                    <td><span class="warn">20-30 Hz</span></td>
                    <td>Minimize audio overhead for gameplay FPS</td>
                </tr>
                <tr>
                    <td class="mono">Music Focused</td>
                    <td><span class="ok">50-60 Hz</span></td>
                    <td>Smoothest audio transitions, best fade quality</td>
                </tr>
                <tr>
                    <td class="mono">Battery Saving</td>
                    <td><span class="warn">20-25 Hz</span></td>
                    <td>Reduce audio update frequency for power efficiency</td>
                </tr>
            </tbody>
        </table>

        <h4>Before/After Examples</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">Audio Quality Differences</div>
            <strong>20 Hz:</strong><br>
            • Music volume changes may have audible "steps"<br>
            • Fade effects sound slightly choppy<br>
            • Sound effect transitions less smooth<br><br>
            <strong>40 Hz (default):</strong><br>
            • Smooth volume fades<br>
            • Natural-sounding transitions<br>
            • Minimal CPU overhead<br><br>
            <strong>60 Hz:</strong><br>
            • Imperceptibly smooth fades<br>
            • Professional audio quality<br>
            • Highest CPU cost
        </div>

        <h4>Side Effects & Warnings</h4>
        <div class="tradeoffs">
            <div class="tradeoffs-title">CPU Cost Scaling</div>
            <strong>20 Hz:</strong> 1x baseline cost<br>
            <strong>40 Hz:</strong> 2x CPU vs 20 Hz<br>
            <strong>60 Hz:</strong> 3x CPU vs 20 Hz<br><br>
            The relationship is linear because mixer runs N times per second regardless of framerate.
        </div>

        <div class="warning-box">
            <strong>Audible Artifacts:</strong> At 20-25 Hz, careful listeners may notice:
            <ul class="small">
                <li>Volume "stair-stepping" during fades</li>
                <li>Reverb tail cut-off or grainy</li>
                <li>Music transitions less polished</li>
            </ul>
            <strong>Recommendation:</strong> Use 40 Hz as minimum for quality experience.
        </div>

        <div class="dev-notes">
            <strong>TECHNICAL NOTE:</strong> Audio mixer frequency is independent of game framerate. The game can run at 30 FPS with audio at 60 Hz - they operate on separate timers. This ensures consistent audio quality even if rendering slows down.
        </div>
    </div>

    <!-- SETTING 8: RENDER -->
    <div class="section-block">
        <div class="section-title">
            <h2>8. RENDER (Renderer Lock)</h2>
            <div>
                <span class="pill">Core #8</span>
                <span class="location-tag">app_full.lua:~398-410 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Forces EXP-H hybrid renderer with proper texture mode. Recovery mechanism for renderer state.</p>

        <h4>Variables & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Variables:
- RENDERER_MODE (string: "exp_hybrid")
- WALL_TEXTURE_MODE (string: "proper")

Key function: lockRendererMode()

Implementation (estimated):
function lockRendererMode()
    RENDERER_MODE = "exp_hybrid"
    WALL_TEXTURE_MODE = "proper"

    -- Re-apply renderer configuration
    applyRendererSettings()

    -- Log state change
    logPerf("Renderer locked to EXP-H + proper")
end

Menu behavior:
- LEFT or RIGHT press both call lockRendererMode()
- No toggle - always re-applies same configuration
- Acts as "reset renderer to known good state"</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: None (re-asserts current mode)</span>
            <span class="performance-metric metric-memory">Memory: None</span>
            <span class="performance-metric metric-fps">FPS: None</span>
        </div>
        <p class="small">This is a state recovery tool, not a performance setting.</p>

        <h4>How It Works - Renderer Architecture</h4>

        <h5>EXP-H Hybrid Renderer</h5>
        <div class="code-block"><pre><span class="mono">EXP-H = "Experimental Hybrid"

Combines:
1. Classic raycasting (Wolfenstein 3D style)
2. Modern texture optimization (mipmapping, LOD)
3. Adaptive quality scaling
4. Fog distance optimization

"Hybrid" aspects:
- Near walls: Full quality textures
- Mid walls: Mipmapped textures
- Far walls: Flat shading or low mip
- Columns choose optimal method dynamically</span></pre></div>

        <h5>"Proper" Texture Mode</h5>
        <div class="code-block"><pre><span class="mono">WALL_TEXTURE_MODE = "proper"

Proper texture projection:
- Perspective-correct texture mapping
- Per-pixel texture coordinates
- Avoids "sliding" texture artifacts
- More expensive than "affine" mode

Alternative modes (historical):
- "flat": Solid colors, no textures
- "fast": Affine mapping (warps at angles)
- "proper": Perspective-correct (current)</span></pre></div>

        <h4>When To Use RENDER Button</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 200px;">Symptom</th>
                    <th>Action</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Textures appear solid colors</td>
                    <td>Press RENDER to re-enable proper texturing</td>
                </tr>
                <tr>
                    <td class="mono">Visual artifacts after crash</td>
                    <td>Press RENDER to reset renderer state</td>
                </tr>
                <tr>
                    <td class="mono">Fog not working</td>
                    <td>Press RENDER to re-apply EXP-H mode</td>
                </tr>
                <tr>
                    <td class="mono">Mipmapping not applying</td>
                    <td>Press RENDER to lock hybrid mode</td>
                </tr>
                <tr>
                    <td class="mono">Testing EXP-H features</td>
                    <td>Press RENDER to ensure active</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>
        <div class="info-box">
            <strong>Historical Context:</strong> Earlier versions supported multiple renderers (classic, EXP, EXP-H). This setting remains from when switching renderers was possible. Now it's a "force current renderer" button for recovery.
        </div>

        <div class="dev-notes">
            <strong>IMPLEMENTATION NOTE:</strong> The RENDER setting is unusual because LEFT and RIGHT do the same thing. There's no toggle - both directions call <code>lockRendererMode()</code>. This is intentional: it's a reset, not a choice.
        </div>

        <div class="warning-box">
            <strong>Not A Toggle:</strong> Users may expect LEFT/RIGHT to cycle through options. Clarify in documentation that this button is a recovery mechanism, not a selection menu.
        </div>
    </div>

    <!-- SETTING 9: RAYCAST -->
    <div class="section-block">
        <div class="section-title">
            <h2>9. RAYCAST (Raycast Method)</h2>
            <div>
                <span class="pill">Core #9</span>
                <span class="location-tag">app_full.lua:~800-1000 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Switches between FIXED (integer trig tables) and FLOAT (vmupro math cos/sin) raycasting</p>

        <h4>Variables & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Variables:
- USE_FIXED_RAYCAST (boolean: true = FIXED, false = FLOAT)
- DEBUG_FORCE_FLOAT_RAYCAST (boolean: override flag)

Default: USE_FIXED_RAYCAST = true

Implementation locations:
- Raycast loop: Uses castCos[] and castSin[] tables if FIXED
- Alternative: Calls vmupro.math.cos() and vmupro.math.sin() if FLOAT

Trigonometry tables (precomputed):
castCos = {}  -- 256 or 512 entries
castSin = {}  -- 256 or 512 entries

Generated at startup:
for i = 0, 511 do
    local angle = (i / 512) * 2 * math.pi
    castCos[i] = math.floor(math.cos(angle) * PRECISION)
    castSin[i] = math.floor(math.sin(angle) * PRECISION)
end</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~0-2% difference (path-dependent)</span>
            <span class="performance-metric metric-memory">Memory: ~2-4 KB for trig tables</span>
            <span class="performance-metric metric-fps">FPS: Negligible in most cases</span>
        </div>

        <h4>How Fixed vs Float Raycasting Works</h4>

        <h5>FIXED Raycasting (Integer Math)</h5>
        <div class="code-block"><pre><span class="mono">Algorithm:
1. Player angle maps to table index (0-511)
2. Look up cos/sin from precomputed arrays
3. Integer ray stepping (DDA algorithm)
4. Wall hit detection using integer math

Advantages:
- Deterministic (same angle = same result every time)
- No floating point rounding errors
- Fast on integer-only hardware
- Consistent visual artifacts (if any)

Code example:
local angleIndex = math.floor(playerAngle * 512 / (2 * math.pi))
local cosVal = castCos[angleIndex]
local sinVal = castSin[angleIndex]

-- Ray march
while true do
    rayX = rayX + cosVal
    rayY = rayY + sinVal
    if isWall(rayX, rayY) then break end
end</span></pre></div>

        <h5>FLOAT Raycasting (Floating Point)</h5>
        <div class="code-block"><pre><span class="mono">Algorithm:
1. Use vmupro.math.cos(playerAngle)
2. Use vmupro.math.sin(playerAngle)
3. Floating-point ray stepping
4. Same DDA wall hit detection

Advantages:
- Higher precision (no table quantization)
- Smoother angle transitions
- Reference implementation for validation
- May handle edge cases better

Code example:
local cosVal = vmupro.math.cos(playerAngle)
local sinVal = vmupro.math.sin(playerAngle)

-- Ray march (same loop)
while true do
    rayX = rayX + cosVal
    rayY = rayY + sinVal
    if isWall(rayX, rayY) then break end
end</span></pre></div>

        <h4>Before/After Visual Differences</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">Subtle Differences</div>
            <strong>FIXED (RIGHT):</strong><br>
            • Slight angle quantization (512 steps per circle)<br>
            • Consistent results - deterministic rendering<br>
            • May show tiny "steps" in very long walls<br><br>
            <strong>FLOAT (LEFT):</strong><br>
            • Mathematically perfect angles<br>
            • Smoother very-long-distance wall edges<br>
            • Reference implementation for A/B testing
        </div>

        <div class="info-box">
            <strong>Practical Reality:</strong> Visual difference between FIXED and FLOAT is nearly imperceptible at 240 rays. The 512-step table provides sufficient resolution. Main use is A/B validation during development.
        </div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Reason</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Production/Release</td>
                    <td><span class="ok">FIXED (RIGHT)</span></td>
                    <td>Deterministic, faster, proven stable</td>
                </tr>
                <tr>
                    <td class="mono">Debugging Rendering</td>
                    <td><span class="warn">FLOAT (LEFT)</span></td>
                    <td>Reference implementation, find edge cases</td>
                </tr>
                <tr>
                    <td class="mono">A/B Testing</td>
                    <td>Compare both</td>
                    <td>Validate FIXED accuracy against FLOAT</td>
                </tr>
                <tr>
                    <td class="mono">Performance Testing</td>
                    <td><span class="ok">FIXED (RIGHT)</span></td>
                    <td>Production configuration, real-world performance</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>
        <div class="tradeoffs">
            <div class="tradeoffs-title">Precision vs Speed</div>
            <strong>FIXED:</strong><br>
            ✓ Deterministic (same seed = same output)<br>
            ✓ 2-4 KB trig table (cached, fast access)<br>
            ✓ Integer math (fast on most hardware)<br>
            ✗ 512-angle quantization<br><br>
            <strong>FLOAT:</strong><br>
            ✓ Perfect precision<br>
            ✓ No table lookup overhead<br>
            ✗ vmupro.math calls may be slower<br>
            ✗ Non-deterministic FP rounding
        </div>

        <div class="dev-notes">
            <strong>DEVELOPMENT USE:</strong> This setting exists for developers to validate that the FIXED implementation produces visually identical results to FLOAT. If you notice rendering artifacts in FIXED but not FLOAT, the trig table resolution may need increasing (currently 512 entries).
        </div>
    </div>

    <!-- SETTING 10: PERF MON -->
    <div class="section-block">
        <div class="section-title">
            <h2>10. PERF MON (Performance Monitor)</h2>
            <div>
                <span class="pill">Core #10</span>
                <span class="location-tag">app_full.lua:~2000-2200 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Real-time performance overlay showing frame timing, raycast/wall/fog costs, adaptive shifts, and memory</p>

        <h4>Variable & Code Location</h4>
        <div class="code-block"><pre><span class="mono">Variable: DEBUG_PERF_MONITOR (boolean)
Default: false (overlay disabled)

Overlay displays (8 lines):
1. Frame time / FPS
2. Raycast time (ms)
3. Wall render time (ms)
4. Fog overlay time (ms)
5. Mip level distribution (0/1/2/3/4 counts)
6. Ray preset shifts (adaptive behavior)
7. Column counts (rendered/skipped)
8. Double-buffer memory delta (bytes)</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~1-2% (overlay rendering)</span>
            <span class="performance-metric metric-memory">Memory: ~100-200 bytes</span>
            <span class="performance-metric metric-fps">FPS: -1-2 when active</span>
        </div>

        <h4>How Performance Monitor Works</h4>

        <h5>Data Collection</h5>
        <div class="code-block"><pre><span class="mono">Timing instrumentation:
local frameStartUs = vmupro.system.getMicroseconds()

-- Raycast pass
local rayStartUs = vmupro.system.getMicroseconds()
castRays()
local rayTimeUs = vmupro.system.getMicroseconds() - rayStartUs

-- Wall pass
local wallStartUs = vmupro.system.getMicroseconds()
renderWalls()
local wallTimeUs = vmupro.system.getMicroseconds() - wallStartUs

-- Fog pass
local fogStartUs = vmupro.system.getMicroseconds()
renderFog()
local fogTimeUs = vmupro.system.getMicroseconds() - fogStartUs

local frameTimeUs = vmupro.system.getMicroseconds() - frameStartUs</span></pre></div>

        <h5>Sampling and EMA</h5>
        <div class="code-block"><pre><span class="mono">To reduce flicker, monitor uses EMA (Exponential Moving Average):

local PERF_MONITOR_SAMPLE_EVERY = 12  -- Sample every 12 frames
local EMA_ALPHA = 0.25  -- Smoothing factor

EMA update:
emaValue = (alpha * newValue) + ((1 - alpha) * emaValue)

This means:
- 25% weight to current value
- 75% weight to previous average
- Results in smooth, readable numbers

Display shows EMA, not raw values.</span></pre></div>

        <h5>Mip Level Distribution</h5>
        <div class="code-block"><pre><span class="mono">Tracks how many columns use each mip level:

mipCounts = {0, 0, 0, 0, 0}  -- MIP 0-4

For each rendered column:
    local mipLevel = getMipLevelForDistance(distance)
    mipCounts[mipLevel] = mipCounts[mipLevel] + 1

Display format:
"MP 15/80/120/20/5"
    ↓  ↓  ↓  ↓  ↓
   M0 M1 M2 M3 M4

Interpretation:
- M0: 15 columns at full resolution
- M1: 80 columns at 1/2 resolution
- M2: 120 columns at 1/4 resolution (most common)
- M3: 20 columns at 1/8 resolution
- M4: 5 columns at minimum resolution</span></pre></div>

        <h4>Before/After Visual Differences</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">On-Screen Overlay</div>
            <strong>PERF MON OFF (LEFT):</strong><br>
            • Clean game view<br>
            • No performance info<br><br>
            <strong>PERF MON ON (RIGHT):</strong><br>
            <div class="code-block"><pre>FRM: 18.5ms / 54 FPS
RAY: 6.2ms (240 rays)
WAL: 8.1ms (180 cols)
FOG: 2.8ms (120 cols)
MP: 15/80/120/20/5
RX: 60x4 → 48x5 (down)
DBUF: +4096 bytes</pre></div>
        </div>

        <h4>Reading the Overlay - Line by Line</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 50px;">Line</th>
                    <th>Example</th>
                    <th>What It Tells You</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">1</td>
                    <td><code>FRM: 18.5ms / 54 FPS</code></td>
                    <td>Total frame time. 18.5ms = ~54 FPS. Target 16.67ms for 60 FPS.</td>
                </tr>
                <tr>
                    <td class="mono">2</td>
                    <td><code>RAY: 6.2ms (240 rays)</code></td>
                    <td>Raycast took 6.2ms. 240 rays = current preset × col width.</td>
                </tr>
                <tr>
                    <td class="mono">3</td>
                    <td><code>WAL: 8.1ms (180 cols)</code></td>
                    <td>Wall rendering took 8.1ms. 180 columns actually rendered.</td>
                </tr>
                <tr>
                    <td class="mono">4</td>
                    <td><code>FOG: 2.8ms (120 cols)</code></td>
                    <td>Fog overlay took 2.8ms. 120 columns needed fog.</td>
                </tr>
                <tr>
                    <td class="mono">5</td>
                    <td><code>MP: 15/80/120/20/5</code></td>
                    <td>Mip distribution. Most columns at MIP2 (mid-distance LOD working).</td>
                </tr>
                <tr>
                    <td class="mono">6</td>
                    <td><code>RX: 60x4 → 48x5 (down)</code></td>
                    <td>Adaptive rays shifted from 60x4 down to 48x5 due to frame time.</td>
                </tr>
                <tr>
                    <td class="mono">7</td>
                    <td><code>COLS: 180/240</code></td>
                    <td>180 rendered, 240 total. 60 columns skipped (occlusion/cull).</td>
                </tr>
                <tr>
                    <td class="mono">8</td>
                    <td><code>DBUF: +4096 bytes</code></td>
                    <td>Double-buffer using 4KB extra memory.</td>
                </tr>
            </tbody>
        </table>

        <h4>Recommended Usage During Tuning</h4>
        <div class="use-cases">
            <div class="use-cases-title">Workflow</div>
            <strong>1. Enable PERF MON</strong> - See baseline performance<br>
            <strong>2. Check bottlenecks:</strong><br>
            &nbsp;&nbsp;&nbsp;• High RAY time? Reduce RAYS preset<br>
            &nbsp;&nbsp;&nbsp;• High WAL time? Reduce DRAW DIST or enable MIPMAP<br>
            &nbsp;&nbsp;&nbsp;• High FOG time? Raise FOG START to reduce fog coverage<br>
            <strong>3. Watch adaptive:</strong><br>
            &nbsp;&nbsp;&nbsp;• Constant shifting = unstable, lower base preset<br>
            &nbsp;&nbsp;&nbsp;• Stable = good configuration<br>
            <strong>4. Check mips:</strong><br>
            &nbsp;&nbsp;&nbsp;• Skewed to MIP0? Mip LOD not aggressive enough<br>
            &nbsp;&nbsp;&nbsp;• Even distribution? Well-tuned<br>
            <strong>5. Disable when done</strong> - Clean up view
        </div>

        <h4>Side Effects & Warnings</h4>
        <div class="tradeoffs">
            <div class="tradeoffs-title">Overhead vs Insight</div>
            <strong>ON:</strong><br>
            ✓ Real-time bottleneck identification<br>
            ✓ Validate adaptive behavior<br>
            ✓ See memory impact<br>
            ✗ 1-2% FPS cost (ironically affects measurement)<br>
            ✗ Screen clutter<br><br>
            <strong>OFF:</strong><br>
            ✓ Clean view<br>
            ✓ No overhead<br>
            ✗ Flying blind on performance
        </div>

        <div class="dev-notes">
            <strong>ACCURACY NOTE:</strong> PERF MON itself adds overhead (timing calls, string formatting). Measurements are slightly inflated. For absolute profiling, use external tools. For relative tuning ("did this setting help?"), PERF MON is accurate enough.
        </div>
    </div>

    <!-- SETTING 11: AUTO RAYS -->
    <div class="section-block">
        <div class="section-title">
            <h2>11. AUTO RAYS (Adaptive Ray Budget)</h2>
            <div>
                <span class="pill">Core #11</span>
                <span class="location-tag">app_full.lua:~2800-3200 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Automatically adjusts ray quality to maintain target FPS. RIGHT = ON, LEFT = OFF</p>

        <h4>Variables & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Primary Variables:
- ADAPTIVE_RAY_BUDGET_ENABLED (boolean)
- ADAPTIVE_RAY_RUNTIME_INDEX (integer: current effective preset)
- ADAPTIVE_RAY_EMA_US (integer: exponential moving average of frame time)
- ADAPTIVE_RAY_COOLDOWN_FRAMES (integer: frames until next shift allowed)

Constants:
- ADAPTIVE_RAY_DOWN_HYST_US = 2200  (2.2ms over target = downshift)
- ADAPTIVE_RAY_UP_HYST_US = 2600    (2.6ms under target = upshift)
- ADAPTIVE_RAY_COOLDOWN_FRAMES = 18  (wait 18 frames between shifts)
- ADAPTIVE_RAY_EMA_ALPHA = 0.2       (smoothing factor)

Key functions:
- updateAdaptiveRayBudget()  (called each frame)
- getAdaptiveRayTargetFrameUs()  (returns target microseconds)
- getBaseEffectiveRayPresetIndex()  (returns ray preset to use)</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: ~0.5% (EMA calculation)</span>
            <span class="performance-metric metric-memory">Memory: ~20 bytes</span>
            <span class="performance-metric metric-fps">FPS: +15-40% stability improvement</span>
        </div>
        <p class="small">Minimal overhead for massive stability gain. The real "cost" is visual quality during downshifts.</p>

        <h4>How Adaptive Ray Budget Works - Algorithm</h4>

        <h5>Step 1: Track Frame Time</h5>
        <div class="code-block"><pre><span class="mono">Every frame:
local frameTimeUs = currentFrameTimeMicroseconds

-- Update EMA (Exponential Moving Average)
ADAPTIVE_RAY_EMA_US = (ADAPTIVE_RAY_EMA_US * (1 - 0.2)) + (frameTimeUs * 0.2)

Why EMA?
- Smooths out frame spikes (single dropped frame doesn't trigger downshift)
- Responds gradually to sustained performance changes
- Alpha 0.2 = ~5 frames to reach 67% of new value</span></pre></div>

        <h5>Step 2: Compare to Target</h5>
        <div class="code-block"><pre><span class="mono">Get target FPS from FPS_TARGET_MODE:
targetUs = getAdaptiveRayTargetFrameUs()
-- Returns 16667 for 60 FPS, 33333 for 30 FPS, etc.

Check thresholds:
downshiftThreshold = targetUs + 2200  (18.87ms for 60 FPS target)
upshiftThreshold = targetUs - 2600     (14.07ms for 60 FPS target)

Hysteresis (gap between thresholds):
- Prevents rapid toggling
- Must be consistently slow to downshift
- Must be consistently fast to upshift</span></pre></div>

        <h5>Step 3: Adjust Ray Preset</h5>
        <div class="code-block"><pre><span class="mono">If cooldown expired:
    if ADAPTIVE_RAY_EMA_US > downshiftThreshold then
        -- Frame time too high, reduce quality
        if ADAPTIVE_RAY_RUNTIME_INDEX > 1 then
            ADAPTIVE_RAY_RUNTIME_INDEX = ADAPTIVE_RAY_RUNTIME_INDEX - 1
            startCooldown()
        end
    elseif ADAPTIVE_RAY_EMA_US < upshiftThreshold then
        -- Frame time low, can increase quality
        local basePreset = RAY_PRESET_INDEX
        if ADAPTIVE_RAY_RUNTIME_INDEX < basePreset then
            ADAPTIVE_RAY_RUNTIME_INDEX = ADAPTIVE_RAY_RUNTIME_INDEX + 1
            startCooldown()
        end
    end

Constraint: Never exceed base preset index
(If user selected 60x4, adaptive can only go down, never to 80x3)</span></pre></div>

        <h5>Step 4: Apply Effective Preset</h5>
        <div class="code-block"><pre><span class="mono">During render:
local effectivePresetIndex = ADAPTIVE_RAY_RUNTIME_INDEX or RAY_PRESET_INDEX
local preset = RAY_PRESETS[effectivePresetIndex]
local rayCols = preset.cols
local colWidth = preset.colWidth

Result:
- Base: 60x4 selected
- Adaptive downshifts to: 48x5 (240 rays, wider columns)
- Further downshift: 40x6 (still 240 rays, even wider)
- Upshifts back when frame time improves</span></pre></div>

        <h4>Before/After Examples</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">Observable Behavior</div>
            <strong>AUTO RAYS OFF (LEFT):</strong><br>
            • Fixed ray count (e.g., always 60x4)<br>
            • Framerate varies: 60 FPS in simple rooms, 35 FPS in complex<br>
            • Visual quality consistent<br>
            • No adaptive indicators in PERF MON<br><br>
            <strong>AUTO RAYS ON (RIGHT):</strong><br>
            • Ray count auto-adjusts: 60x4 → 48x5 → 60x4<br>
            • Framerate stabilizes near target (e.g., always 58-60 FPS)<br>
            • Visual quality fluctuates slightly<br>
            • PERF MON shows: "RX: 60x4 → 48x5 (down)"
        </div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Why</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Most Gameplay</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Stable framerate worth minor quality fluctuation</td>
                </tr>
                <tr>
                    <td class="mono">Benchmarking</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>See true performance of each preset without interference</td>
                </tr>
                <tr>
                    <td class="mono">Quality Priority</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Prefer consistent quality over framerate stability</td>
                </tr>
                <tr>
                    <td class="mono">Slow Hardware</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Essential for playability - find sustainable preset</td>
                </tr>
                <tr>
                    <td class="mono">Screenshots</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Lock to highest quality, wait for good frame</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>

        <div class="warning-box">
            <strong>Quality Fluctuation:</strong> When AUTO RAYS is ON, you may notice:
            <ul class="small">
                <li>Distant walls become blockier during complex scenes</li>
                <li>Visual "popping" when preset shifts</li>
                <li>Slight stutter when downshift happens (one rough frame)</li>
            </ul>
            This is intentional - trading visual quality for framerate stability.
        </div>

        <div class="tradeoffs">
            <div class="tradeoffs-title">Stability vs Consistency</div>
            <strong>ON (Adaptive):</strong><br>
            ✓ Stable framerate (±2 FPS of target)<br>
            ✓ Automatic handling of scene complexity<br>
            ✓ Better battery life (downscales in heavy scenes)<br>
            ✗ Quality fluctuates<br>
            ✗ May shift during critical gameplay moments<br><br>
            <strong>OFF (Fixed):</strong><br>
            ✓ Consistent visual quality<br>
            ✓ Predictable performance<br>
            ✗ Framerate varies wildly (20-80 FPS swings)<br>
            ✗ May be unplayable in complex scenes
        </div>

        <div class="dev-notes">
            <strong>TUNING TIP:</strong> If adaptive constantly shifts (e.g., "60x4→48x5→60x4→48x5"), your base preset is too high for stable operation. Lower RAYS by one step to stop oscillation.
        </div>

        <div class="info-box">
            <strong>COOLDOWN MECHANISM:</strong> The 18-frame cooldown (~0.3 seconds at 60 FPS) prevents rapid toggling. Without it, a single heavy frame would cause downshift, next frame would upshift, creating visual chaos. Cooldown ensures sustained performance before changing.
        </div>
    </div>

    <!-- SETTING 12: DBUF (Double Buffer) -->
    <div class="section-block">
        <div class="section-title">
            <h2>12. DBUF (Double Buffer)</h2>
            <div>
                <span class="pill">Core #12</span>
                <span class="location-tag">app_full.lua:~500-700 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Enables double-buffered rendering to prevent screen tearing. RIGHT = ON, LEFT = OFF</p>

        <h4>Variables & Code Locations</h4>
        <div class="code-block"><pre><span class="mono">Variables:
- DEBUG_DOUBLE_BUFFER (boolean: menu flag)
- DOUBLE_BUFFER_ACTIVE (boolean: hardware-supported state)
- DOUBLE_BUFFER_DELTA_USAGE_BYTES (integer: memory overhead)

Key functions:
- applyDoubleBufferMode() - Toggles and tracks state
- startDoubleBufferRenderer() - Activates hardware double buffering
- stopDoubleBufferRenderer() - Deactivates, falls back to single buffer

Menu logic:
When user changes DBUF setting:
1. Call applyDoubleBufferMode()
2. Try startDoubleBufferRenderer()
3. If success, set DOUBLE_BUFFER_ACTIVE = true
4. Track memory delta in DOUBLE_BUFFER_DELTA_USAGE_BYTES
5. Menu shows ON only if both flag AND active are true</span></pre></div>

        <h4>Performance Impact</h4>
        <div class="impacts">
            <span class="performance-metric metric-cpu">CPU: None (memory copy operation)</span>
            <span class="performance-metric metric-memory">Memory: +3-8 KB frame buffer</span>
            <span class="performance-metric metric-fps">FPS: None (may improve perceived smoothness)</span>
        </div>

        <h4>How Double Buffering Works</h4>

        <h5>Single Buffer (DBUF OFF)</h5>
        <div class="code-block"><pre><span class="mono">Render flow (single buffer):
1. Clear screen
2. Render walls to display buffer
3. Render sprites to display buffer
4. Render UI to display buffer
5. Display updates immediately

Problem:
- Display may update while frame is partially drawn
- Results in "tearing" (horizontal split showing old/new frame)
- Especially visible during fast camera movement

Visual artifact:
┌─────────────────┐
│  New frame     │ ← Top of screen updated
├─────────────────┤ ← Tearing line
│  Old frame     │ ← Bottom still showing previous frame
└─────────────────┘</span></pre></div>

        <h5>Double Buffer (DBUF ON)</h5>
        <div class="code-block"><pre><span class="mono">Render flow (double buffer):
1. Clear OFF-SCREEN buffer
2. Render walls to off-screen buffer
3. Render sprites to off-screen buffer
4. Render UI to off-screen buffer
5. Atomic swap: Off-screen → Display buffer
6. Display updates complete frame only

Benefits:
- No tearing (swap happens instantaneously)
- Smoother appearance during fast movement
- Professional, polished look

Memory cost:
- Second frame buffer: 220 × 176 pixels × 2 bytes/pixel
- Approximately: 77,440 bytes = ~75 KB
- Implementation may use less (partial buffer, compression)</span></pre></div>

        <h4>Before/After Visual Differences</h4>
        <div class="visual-diff">
            <div class="visual-diff-title">Screen Tearing</div>
            <strong>DBUF OFF (LEFT):</strong><br>
            • During fast camera turns, horizontal "tear" visible<br>
            • Top half shows new frame, bottom shows old<br>
            • Can be jarring and look like bugs<br>
            • Especially noticeable at 60 FPS<br><br>
            <strong>DBUF ON (RIGHT):</strong><br>
            • Smooth, artifact-free rendering<br>
            • No tearing regardless of movement speed<br>
            • Professional presentation<br>
            • Uses extra memory (3-8 KB reported, likely compressed buffer)
        </div>

        <h4>Recommended Values by Scenario</h4>
        <table>
            <thead>
                <tr>
                    <th style="width: 180px;">Scenario</th>
                    <th>Setting</th>
                    <th>Rationale</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="mono">Production/Release</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Polished experience, no tearing artifacts</td>
                </tr>
                <tr>
                    <td class="mono">Memory Constrained</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Save 3-8 KB if absolutely necessary</td>
                </tr>
                <tr>
                    <td class="mono">Benchmarking</td>
                    <td><span class="warn">OFF (LEFT)</span></td>
                    <td>Measure pure rendering, exclude buffer copy overhead</td>
                </tr>
                <tr>
                    <td class="mono">Video Streaming</td>
                    <td><span class="ok">ON (RIGHT)</span></td>
                    <td>Viewers see clean footage without tearing</td>
                </tr>
            </tbody>
        </table>

        <h4>Side Effects & Warnings</h4>

        <div class="warning-box">
            <strong>Hardware Dependency:</strong> Double buffering may not be supported on all devices:
            <ul class="small">
                <li>If hardware lacks VRAM, setting fails silently</li>
                <li>Menu shows OFF even if user selected ON</li>
                <li>Check DOUBLE_BUFFER_ACTIVE to verify actual state</li>
            </ul>
            <strong>Fallback:</strong> System automatically uses single buffer if double buffering unavailable.
        </div>

        <div class="tradeoffs">
            <div class="tradeoffs-title">Memory vs Quality</div>
            <strong>ON (Double Buffer):</strong><br>
            ✓ No tearing<br>
            ✓ Smoother appearance<br>
            ✓ Professional presentation<br>
            ✗ +3-8 KB memory (report) or ~75 KB (theoretical full buffer)<br>
            ✗ May fail on low-memory hardware<br><br>
            <strong>OFF (Single Buffer):</strong><br>
            ✓ Lower memory footprint<br>
            ✓ Guaranteed to work on all hardware<br>
            ✗ Tearing during fast movement<br>
            ✗ Less polished appearance
        </div>

        <div class="dev-notes">
            <strong>MEMORY DISCREPANCY:</strong> The reported 3-8 KB seems low for a full 220×176×2-byte buffer (~77 KB). Possible explanations:
            <ul class="small">
                <li>Partial buffer (only dirty regions)</li>
                <li>Compressed buffer format</li>
                <li>Differential tracking (only changes stored)</li>
                <li>Hardware-accelerated buffer sharing</li>
            </ul>
            Regardless, trust DOUBLE_BUFFER_DELTA_USAGE_BYTES for actual overhead.
        </div>

        <div class="info-box">
            <strong>IMPLEMENTATION NOTE:</strong> The menu item tracks both DEBUG_DOUBLE_BUFFER (user setting) AND DOUBLE_BUFFER_ACTIVE (hardware state). This prevents showing "ON" when the feature isn't actually working due to hardware limitations.
        </div>
    </div>

    <!-- SETTING 13: BACK -->
    <div class="section-block">
        <div class="section-title">
            <h2>13. BACK (Navigation)</h2>
            <div>
                <span class="pill">Core #13</span>
                <span class="location-tag">app_full.lua:~527-537 (estimated)</span>
            </div>
        </div>

        <h3>Overview</h3>
        <p>Exits debug menu and returns to Options. Only row that responds to A/MODE button.</p>

        <h4>Code Location</h4>
        <div class="code-block"><pre><span class="mono">Menu item definition:
{label = "BACK", action = "exit"}

Input handling:
if button == "A" or button == "MODE" then
    if menuItems[cursor].action == "exit" then
        closeDebugMenu()
        returnToOptionsMenu()
    end
end

Behavior:
- LEFT/RIGHT: No effect (setting has no value)
- A/MODE: Confirms exit, closes menu
- B/POWER: Also exits (global menu exit)</span></pre></div>

        <h4>How It Works</h4>
        <p class="small">The BACK item is a navigation convenience. Pressing A on any other menu row does nothing (only LEFT/RIGHT work). BACK responds to A/MODE to provide explicit "done" action.</p>

        <h4>Apply vs Cancel</h4>
        <div class="info-box">
            <strong>IMPORTANT:</strong> Most debug settings apply IMMEDIATELY when changed. You do NOT need to press BACK to save changes. BACK simply exits the menu interface.
        </div>

        <h4>Menu State Persistence</h4>
        <div class="code-block"><pre><span class="mono">Settings persist in global variables:
- Debug flags (DEBUG_DISABLE_ENEMIES, etc.)
- Quality presets (RAY_PRESET_INDEX, etc.)
- Toggle states (showFpsOverlay, etc.)

When you exit debug menu and return:
- All settings remain as you left them
- Cursor position resets to top
- Page resets to DEBUG

No explicit "save" needed - changes are live.</span></pre></div>
    </div>

    <!-- SUMMARY TABLE -->
    <div class="card">
        <h2>Core Settings Quick Reference Summary</h2>
        <table>
            <thead>
                <tr>
                    <th style="width: 40px;">#</th>
                    <th style="width: 150px;">Setting</th>
                    <th style="width: 100px;">CPU Impact</th>
                    <th style="width: 100px;">Memory Impact</th>
                    <th>Best For</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td class="mono">PAGE</td>
                    <td><span class="impact-low">None</span></td>
                    <td><span class="impact-low">None</span></td>
                    <td>Navigation between pages</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td class="mono">LOGS</td>
                    <td><span class="impact-medium">2-5%</span></td>
                    <td><span class="impact-low">~1-2 KB</span></td>
                    <td>Development, debugging</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td class="mono">ENEMIES</td>
                    <td><span class="impact-high">15-25%</span></td>
                    <td><span class="impact-medium">~500-2000 bytes</span></td>
                    <td>Benchmarking, screenshots (when OFF)</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td class="mono">PROPS</td>
                    <td><span class="impact-medium">5-12%</span></td>
                    <td><span class="impact-medium">~200-800 bytes</span></td>
                    <td>Renderer testing (when OFF)</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td class="mono">BLOCK DBG</td>
                    <td><span class="impact-low">~1%</span></td>
                    <td><span class="impact-low">~50 bytes</span></td>
                    <td>Combat balancing, learning</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td class="mono">FPS TARGET</td>
                    <td><span class="impact-low">Controls pacing</span></td>
                    <td><span class="impact-low">None</span></td>
                    <td>Performance ceiling, battery saving</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td class="mono">AUDIO MIX</td>
                    <td><span class="impact-low">1-3%</span></td>
                    <td><span class="impact-low">Minimal</span></td>
                    <td>Audio quality tuning</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td class="mono">RENDER</td>
                    <td><span class="impact-low">None</span></td>
                    <td><span class="impact-low">None</span></td>
                    <td>Renderer recovery</td>
                </tr>
                <tr>
                    <td>9</td>
                    <td class="mono">RAYCAST</td>
                    <td><span class="impact-low">0-2%</span></td>
                    <td><span class="impact-medium">~2-4 KB</span></td>
                    <td>A/B testing (FLOAT vs FIXED)</td>
                </tr>
                <tr>
                    <td>10</td>
                    <td class="mono">PERF MON</td>
                    <td><span class="impact-medium">1-2%</span></td>
                    <td><span class="impact-low">~100-200 bytes</span></td>
                    <td>Performance tuning (always when tuning)</td>
                </tr>
                <tr>
                    <td>11</td>
                    <td class="mono">AUTO RAYS</td>
                    <td><span class="impact-low">~0.5%</span></td>
                    <td><span class="impact-low">~20 bytes</span></td>
                    <td>Stable framerate (ON), testing (OFF)</td>
                </tr>
                <tr>
                    <td>12</td>
                    <td class="mono">DBUF</td>
                    <td><span class="impact-low">None</span></td>
                    <td><span class="impact-medium">+3-8 KB</span></td>
                    <td>Polished presentation (ON)</td>
                </tr>
                <tr>
                    <td>13</td>
                    <td class="mono">BACK</td>
                    <td><span class="impact-low">None</span></td>
                    <td><span class="impact-low">None</span></td>
                    <td>Exit menu</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- PERFORMANCE PRESETS -->
    <div class="card">
        <h2>Recommended Core Settings by Use Case</h2>

        <h3>Debugging & Development Preset</h3>
        <div class="use-cases">
            <strong>Configuration:</strong>
            <div class="grid">
                <div>
                    LOGS: ON<br>
                    ENEMIES: YOUR CHOICE<br>
                    PROPS: YOUR CHOICE<br>
                    BLOCK DBG: ON<br>
                    FPS TARGET: UNCAPPED
                </div>
                <div>
                    RAYCAST: FLOAT (for testing)<br>
                    PERF MON: ON<br>
                    AUTO RAYS: OFF (for testing)<br>
                    DBUF: ON
                </div>
            </div>
            <div class="small" style="margin-top: 8px;">
                <strong>Rationale:</strong> Full visibility into performance and rendering behavior. Float raycast validates fixed implementation. PERF MON essential for tuning.
            </div>
        </div>

        <h3>Performance Benchmarking Preset</h3>
        <div class="use-cases">
            <strong>Configuration:</strong>
            <div class="grid">
                <div>
                    LOGS: OFF<br>
                    ENEMIES: OFF<br>
                    PROPS: OFF<br>
                    BLOCK DBG: OFF<br>
                    FPS TARGET: UNCAPPED
                </div>
                <div>
                    RAYCAST: FIXED<br>
                    PERF MON: ON<br>
                    AUTO RAYS: OFF<br>
                    DBUF: OFF (for pure test)
                </div>
            </div>
            <div class="small" style="margin-top: 8px;">
                <strong>Rationale:</strong> Isolates pure renderer performance. No entities, no adaptive interference, no double-buffer overhead. Shows true maximum capability.
            </div>
        </div>

        <h3>Screenshot/Video Preset</h3>
        <div class="use-cases">
            <strong>Configuration:</strong>
            <div class="grid">
                <div>
                    LOGS: OFF<br>
                    ENEMIES: ON or OFF (aesthetic choice)<br>
                    PROPS: ON<br>
                    BLOCK DBG: OFF<br>
                    FPS TARGET: 60 or UNCAPPED
                </div>
                <div>
                    RAYCAST: FIXED<br>
                    PERF MON: OFF<br>
                    AUTO RAYS: ON<br>
                    DBUF: ON
                </div>
            </div>
            <div class="small" style="margin-top: 8px;">
                <strong>Rationale:</strong> Clean visuals (no debug text), smooth rendering (DBUF on), stable quality (auto rays). Enemies/props off for architectural shots, on for action scenes.
            </div>
        </div>

        <h3>Maximum Gameplay Performance Preset</h3>
        <div class="use-cases">
            <strong>Configuration:</strong>
            <div class="grid">
                <div>
                    LOGS: OFF<br>
                    ENEMIES: ON (gameplay required)<br>
                    PROPS: ON (gameplay required)<br>
                    BLOCK DBG: OFF<br>
                    FPS TARGET: 30-45
                </div>
                <div>
                    RAYCAST: FIXED<br>
                    PERF MON: ON (initially)<br>
                    AUTO RAYS: ON<br>
                    DBUF: ON
                </div>
            </div>
            <div class="small" style="margin-top: 8px;">
                <strong>Rationale:</strong> Keep enemies/props for actual gameplay. Lower FPS target gives more headroom. Auto rays maintains stability. PERF MON helps find other bottlenecks (VIDEO settings).
            </div>
        </div>
    </div>

    <div class="card">
        <h2>Documentation Metadata</h2>
        <p class="small">
            <strong>Source:</strong> Enhanced analysis of <span class="mono">IS BUILD FILES/app_full.lua</span> lines 1-5000<br>
            <strong>Verification:</strong> Cross-referenced with NEWDEBUGGUIDE.html for consistency<br>
            <strong>Note:</strong> The "8 CORE settings" requested (Debug Mode, FPS Display, Position Display, Collision Debug, Raycast Debug, Sprite Debug, Auto-Run, God Mode) are not present in the current codebase. This document covers the actual 13 Core settings that exist.
        </p>
    </div>
</div>
</body>
</html>